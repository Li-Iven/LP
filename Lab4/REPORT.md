# Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Ивенкова Л.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     5-        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Для обработки естественных и искусственных языков обычно применяются такие подходы как представление выражения или фразы в виде символьного дерева, для их анализа форм слов могут использоваться специально составленные словари. Так же часто для решения таких задач в начале составляют грамматику.

Prolog оказывается удобным языком для решения таких задач, так как, например, для представления выражения в виде дерева (например при его переводе в префиксную форму) на традиционном языке, потребовалось бы описывать понятие дерева, вводить новые типы данных, пришлось бы работать с указателями и т.д. В Prolog же этого всего нет, тут мы легко и просто сразу начинаем рекурсивно разбирать выражение.

## Задание

Генеалогическое дерево задано фактами вида:

```prolog
parent(alexei, tolia).
parent(alexei, volodia).
parent(tolia, tima).
```

Написать программу на Прологе, запросы к которой будут выглядеть следующим образом:

```prolog
answer([volodia,brat,toli,'?'], X).
answer([kto,tolin,brat,'?'], X).
answer([chei,brat,volodia,'?'], X).
```

Результаты: true, X = volodia, X = tolia.

P.S. Я немного расщирила количество фактов, добавив к ним:

```prolog
parent(alexei, vitia).
parent(tima, sasha).
```


## Принцип решения

**Для начала составляем граматику:**

G = <VT, VN, S, P>

VT = {alexei, tolia, volodia, tima, vitia, sasha}  
VN = {name, kto brat, chei}  
S = ФР  
P:   
ФР -> kto brat name | chei name | name name  
name -> parent(P, name).  
kto brat -> parent(P,Brat), Brat \\= name.  
chei -> parent(P,Brat), Brat \\= name.  


**Принцип решения:**

1. Для начала определяем структуру запроса (порядок слов в нём):  
   a) kto brat name;  
   b) chei name brat;  
   c) name brat name.  
2. Потом анализируем эти запросы, вытаскиваем оттуда имена, проверяем что такие имена есть у нас в базе фактов и переводим их в каноническую форму. Для анализа различных форм имён мы используем созданный нами словарь.
3. Затем составляем правила перехода от этих имен к запросам вида parent(X,Y) для поиска братьев по данной нам базе фактов:
   - В случаях a) и b)  составляем правило parent(P,name), parent(P,brat), brat \\= name, которое находит нам всех братьев.
   - В случае c) составляем правило parent(P,name1), parent(P,name2), name \\= name2

**Код программы:**

```prolog
parent(alexei, tolia).
parent(alexei, volodia).
parent(tolia, tima).
parent(tima, sasha).

% ввели оператор ':' для словаря
:- op(200, xfy, ':').

% словарь, генерирующий различные формы имён
gen(File) :- File = [
    'alexei':pad('именит'):['alexei'],
    'alexei':pad('родит'):['alexeia'],
    'alexei':pad('чей'):['leshin'],
    'tolia':pad('именит'):['tolia'],
    'tolia':pad('родит'):['toli'],
    'tolia':pad('чей'):['tolin'],
    'volodia':pad('именит'):['volodia'],
    'volodia':pad('родит'):['volodi'],
    'volodia':pad('чей'):['volodin'],
    'sasha':pad('именит'):['sasha'],
    'sasha':pad('родит'):['sashi'],
    'sasha':pad('чей'):['sashin'],
    'tima':pad('именит'):['tima'],
    'tima':pad('родит'):['timi'],
    'tima':pad('чей'):['timin'],
    'vitia':pad('именит'):['vitia'],
    'vitia':pad('родит'):['viti'],
    'vitia':pad('чей'):['vitin']
].

% предикат поиска по словарю
fin(X, XC, K, File) :- 
    member(M, File),
    condition(X, XC, K, M).

condition(X, XC, K, XC:K:L) :- member(X, L).

% предикат анализа фразы
answer([X,Y,_,_], Res) :- 
    X = 'kto',
    an_name(Y1, pad('чей'), Y),
    parent(P,Y1), parent(P,Res), Y1 \= Res.

answer([X,_,Z,_], Res) :- 
    X = 'chei',
    an_name(Z1, pad('именит'), Z),
    parent(P,Z1), parent(P,Res), Z1 \= Res.

answer([X,_,Z,_], _) :- 
    an_name(X1, pad('именит'), X),
    an_name(Z1, pad('родит'), Z),
    parent(P,X1), parent(P,Z1), X1 \= Z1.

% предикат анализа слова, проверяющий что это слово - имя из базы фактов
an_name(XC, K, X) :- gen(File), fin(X, XC, K, File).
```

## Результаты

```prolog
2 ?- answer([volodia,brat,toli,'?'], X).
true

3 ?- answer([kto,tolin,brat,'?'], X).
X = volodia ;
X = vitia 

4 ?- answer([chei,brat,vitia,'?'], X).   
X = tolia ;
X = volodia ;

```


## Выводы

В этой лабораторной работе я научилась анализировать естественно-языковые тексты в системе логического программирования, смогла реализовать фрагмент естественно-языкового интерфейса к можельной задаче. Так же я познакомилась с таким понятием как грамматика.

Пролог оказался очень удобен при решении задач грамматического разбора - тут не надо вводить новые типы данных, или работать с указателями.

Я научилась вводить новые операторы и составлять специальные словари для анализа входных фраз. 


