# Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

# Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Ивенкова Л.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Во многих логических задачах заданы начальное о конечное состояния системы и какие-либо условия поведения. И требуется найти последовательность действий, которая приведёт из начального состояния в конечное. Такие задачи удобным образом решаются методом поиска в пространстве состояний.

Prolog оказывается удобным языком для решения таких задач, так как в нём легко можно генерировать искомую последовательность действий, описывать алгоритмы поисков (а поиск в глубину является фактически "родным" для Prolog'а, так как Prolog сам использует поиск в глубину при обходе дерева вывода).

## Задание

"Расстановка мебели"
Площадь разделена на шесть квадратов, пять из них заняты мебелью, шестой - свободен. Переставить мебель так, чтобы шкаф и кресло поменялись местами, при этом никакие два предмета не могут стоять на одном квадрате.

| | | |
|-|-|-|
| стол | стул | шкаф |
| стул |      | кресло |

## Принцип решения

Опишите своими словами принцип решения задачи, приведите важные фрагменты кода. Какие алгоритмы поиска вы использовали?

1. Для начала составим базу фактов - возможных способов обмена местами двух предметов мебели (пустую комнату обозначим как 0):

   ```prolog
   st([0,B,C,D,E,F],[B,0,C,D,E,F]).
   st([A,0,C,D,E,F],[A,C,0,D,E,F]).
   st([A,B,C,0,E,F],[A,B,C,E,0,F]).
   st([A,B,C,D,0,F],[A,B,C,D,F,0]).
   st([0,B,C,D,E,F],[D,B,C,0,E,F]).
   st([A,0,C,D,E,F],[A,E,C,D,0,F]).
   st([A,B,0,D,E,F],[A,B,F,D,E,0]).
   ```

   При таком отображении условия у нас "вершинами графа" будут являться состояния системы - шести комнат (какая из них чем занята)

2. Затем создадим предикат move, который будет показывать, что два пердмета можно поменять местами (при этом он работает и в обратную сторону):

   ```prolog
   % предикат, показывающий, что предметы A и B можно поменять местами
   move(A,B) :- 
       st(A,B);
       st(B,A).
   ```

3. Далее мы составляем алгоритмы поиска решений. Я использовала три алгоритма поиска:

   - Поиск в глубину

      ```prolog
      % основной предикат поиска в глубину
      search_dpth(Start,Finish) :- dpth([Start],Finish,Way), show_answer(Way).
      % рекурсивный поиск в глубину
      dpth([Finish|Tail],Finish,[Finish|Tail]).
      dpth(TempWay,Finish,Way):-prolong(TempWay,NewWay), dpth(NewWay,Finish,Way).
      ```

   - Поиск в ширину
   
      ```prolog
      % основной предикат поиска в ширину
      search_bdth(Start,Finish) :- bdth([[Start]], Finish, Way), show_answer(Way).
      % рекурсивный поиск в ширину
      bdth([[X|T]|_], X, [X|T]).
      bdth([P|QI], X, R) :- 
          findall(Z, prolong(P, Z), T),
          append(QI, T, QO), !,
          bdth(QO, X, R).
      bdth([_|T], Y, L) :- bdth(T, Y, L).
      ```
   - Поиск в глубину с итерационным заглублением

      ```prolog
      % основной предикат поиска в глубину с итеративным заглублением
      search_idth(Start,Finish) :- search_id(Start,Finish, Way), show_answer(Way).

      search_id(Start,Finish,Path,DepthLimit) :- depth_id([Start],   Finish,Path,DepthLimit).
      depth_id([Finish|Tail],Finish,[Finish|Tail],0).
      depth_id(Path,Finish,R,N) :- 
          N>0,
          prolong(Path,NewPath),
          N1 is N-1,
          depth_id(NewPath,Finish,R,N1).
      % рекурсивный поиск в глубину с итеративным заглублением
      search_id(Start,Finish,Path) :- 
          int(Limit),
          search_id(Start,Finish,Path,Limit).

      % предикат, генирирующий глубину поиска от 1 и далее
      int(1).
      int(M) :- int(N), M is N+1.
      ```

   Тут предикат prolong продляет наш путь решений на один шаг:

   ```prolog
   % продление пути
   prolong([Temp|Tail],[New,Temp|Tail]) :-
       move(Temp,New),
       not(member(New, [Temp|Tail])).
   ```

   А предикат show_answer выводит найденные решения в удобном виде. Вот его реализация:

   ```prolog
   % вывод результата
   show_answer([_]):-!.
   show_answer([A,B|Tail]):-show_answer([B|Tail]),nl,write(B),write(' -> '),write(A).
   ```

## Результаты

Я ввела запросы

```prolog
? - search_dpth(['С', 'с', 'ш', 'с', 0, 'к'], ['С', 'с', 'к', 'с', 0, 'ш']).

? - search_bdth(['С', 'с', 'ш', 'с', 0, 'к'], ['С', 'с', 'к', 'с', 0, 'ш']).

? - search_idth(['С', 'с', 'ш', 'с', 0, 'к'], ['С', 'с', 'к', 'с', 0, 'ш']).
``` 

Тут:  
С = стол  
с = стул  
ш = шкаф  
к = кресло   
0 = пустая комната  

Алгоритм поиска в глубину нашел первым путь, состоящий из 247 шагов. Алгоритмы же поиска в ширину и в глубину с итерационным заглблением первым нашли кратчайший путь - он состоит из 19 шагов:

```prolog
[С,с,ш,с,0,к] -> [С,с,ш,с,к,0]
[С,с,ш,с,к,0] -> [С,с,0,с,к,ш]
[С,с,0,с,к,ш] -> [С,0,с,с,к,ш]
[С,0,с,с,к,ш] -> [С,к,с,с,0,ш]
[С,к,с,с,0,ш] -> [С,к,с,0,с,ш]
[С,к,с,0,с,ш] -> [0,к,с,С,с,ш]
[0,к,с,С,с,ш] -> [к,0,с,С,с,ш]
[к,0,с,С,с,ш] -> [к,с,0,С,с,ш]
[к,с,0,С,с,ш] -> [к,с,ш,С,с,0]
[к,с,ш,С,с,0] -> [к,с,ш,С,0,с]
[к,с,ш,С,0,с] -> [к,0,ш,С,с,с]
[к,0,ш,С,с,с] -> [0,к,ш,С,с,с]
[0,к,ш,С,с,с] -> [С,к,ш,0,с,с]
[С,к,ш,0,с,с] -> [С,к,ш,с,0,с]
[С,к,ш,с,0,с] -> [С,к,ш,с,с,0]
[С,к,ш,с,с,0] -> [С,к,0,с,с,ш]
[С,к,0,с,с,ш] -> [С,0,к,с,с,ш]
[С,0,к,с,с,ш] -> [С,с,к,с,0,ш]
```

Но при этом поиск всех решений во всех трёх поисках работал очень долго, выводя очень много решений. Заканчивалось всё переполнением стека. Поэтому время работы поисков не удалось замерить.

Для проверки я ввела ещё такие запросы, где для решения требуется одно действие. Например такой:

```prolog
? - search_dpth(['С', 'с', 'ш', 'с', 0, 'к'], ['С', 'с', 'ш', 'с', 'к', 0]).

? - search_bdth(['С', 'с', 'ш', 'с', 0, 'к'], ['С', 'с', 'ш', 'с', 'к', 0]).

? - search_idth(['С', 'с', 'ш', 'с', 0, 'к'], ['С', 'с', 'ш', 'с', 'к', 0]).
``` 

В этом случае во всех трёх поисках первым вывелся кратчайший путь (который в одно действие):

```prolog
[С,с,ш,с,0,к] -> [С,с,ш,с,к,0]
``` 


## Выводы

В этой лабораторной работе я позникомилась с новым методом решения логических задач - поиском в пространстве состояний. Я научилась писать различные алгоритмы поиска на языке Prolog.

Так же я выяснила, плюсы и минусы каждого поиска. Например, алгоритм поиска в глубину работает быстрее других. Но при этом пути он выводит в случайном порядке - первым не обязательно будет кратчайший. А поиски в ширину и с заглублением сначала выводят оптимальный путь, но при этом алгоритм поиска в ширину намного требовательней по памяти, так он хранит в очереди множество различных путей. 

В моём же случае оптимальными оказались поиски в ширину и с заглублением.





