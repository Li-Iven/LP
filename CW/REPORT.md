# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Ивенкова Л.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ((11-1)+3) mod 4 + 1 = 2: с использованием предикатов parent(родитель, ребёнок), sex(человек, m/f).
 3. Реализовать предикат проверки/поиска ((11-1) mod 7)+1 = 4: Двоюродный брат.
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве.
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Я зарегестрировалась на сайте https://www.myheritage.com/ и создала там своё родословное дерево. Оно состоит из 75 человек. Однако я не знала фамилий некоторых людей, так что указала только их имя. Иногда имена повторялись, тогда я дописывала к ним номер, например: Александр_1. Это нужно, чтобы в будущем при работе с файлом prolog не возникало путаницы в запросах. После всего этого я экспортировала дерево с сайта на свой компьютер.

## Конвертация родословного дерева

Для создания парсера я решила использовать язык Python, так как:
- Во-первых, он легко учится с нуля;
- А во-вторых, в нём легко работать со строками, файлами и массивами.

**Принцип работы программы**

1) Я построчно читаю файл three.ged
2) Если необходимо, делаю транслитерацию имён.
3) Затем создаю два словаря: dict_names и dict_sex, где я буду хранить ID людей плюс их имена и пол соответственно. Читаю файл и заполняю эти словари.
4) Далее создаю массив familys. Затем прохожусь по списку семей в ged-файле. В переменные hus, wife и child записываю имена мужа, жены и ребёнка соответственно. 
5) Затем проверяю, не пусты ли hus и wife. Если нет, то составляю пару "hus, ребёнок" или  "wife, ребёнок".
6) Когда встречаю в строке сочетание "RIN MH:F" (стоящее в конце семей), я делаю hus и wife пустыми.
7) В итоге у нас формируются все нужные нам пары (parent(родитель, ребёнок), sex(человек, m/f)). Мы открываем файл с tree.pl и записываем их туда. Сначала sex(человек, m/f), а потом (parent(родитель, ребёнок), т.к. если вывести их вперемешку, то prolog-файл не примет этого.

```python
with open ('F:\\Luba\\ВУЗы\\2 курс\\Логпрог\\КП\\three.ged', 'r', encoding="utf-8") as file:
    dict_names = {}
    dict_sex = {}
    familys = []
    for line in file:
        info = line.replace('\n','')
        
        if info.find("NAME")>0 and info.find("Herit")<0 and info.find("NAME  //")<0:
            info = info.replace("/","").rstrip()
            #Транслитерация ...#
            x = info[7:]
        if info.find("SEX")>0:
            info.rstrip()
            y = info[6:]
        if info.find("RIN MH:I")>0:
            info.rstrip()
            z = info[10:]
            dict_names[z]=x
            dict_sex[z]=y
            
        if info.find("HUSB")>0:
            info.rstrip()
            hus = info[9:len(info)-1]
        if info.find("WIFE")>0:
            info.rstrip()
            wife = info[9:len(info)-1]
        if info.find("CHIL")>0:
            info.rstrip()
            child = info[9:len(info)-1]
            if (len(hus)>0):
                familys.append([dict_names[hus],dict_names[child]])
            if (len(wife)>0):
                familys.append([dict_names[wife],dict_names[child]])
        if info.find("RIN MH:F")>0:
            hus=""
            wife=""

    with open ('F:\\Luba\\ВУЗы\\2 курс\\Логпрог\\КП\\three.pl', 'w', encoding="utf-8") as f:
        for i in dict_sex:
            f.write("sex('"+dict_names[i]+"', '"+dict_sex[i]+"').\n")

        for i in familys:
            f.write("parent('"+i[0]+"', '"+i[1]+"').\n")
        f.close()
```


## Предикат поиска родственника

Требуется реализовать предикат проверки/поиска двоюродного брата.

Чтобы найти двоюродных братьев какого-нибудь человека, надо ввести запрос: cousin('<имя человека>', X).  
Чтобы определить, является ли человек чьим-нибудь двоюродным братом, надо написать: cousin(X, '<имя человека>').  

Как работает предикат поиска двоюродного брата:

1) Проверяем, что у '<имя человека>' и X есть общие бабушка или дедушка (т.е. их родители приходятся друг другу братом или сестрой). 
2) Проверяем, что пол X - мужской.
3) Проверяем, что X не является братом '<имя человека>'.

Исходный код:  

```prolog
brother(X,Y) :- parent(A,X), parent(A,Y).  
cousin(X,Y) :- parent(A,X), parent(B,Y), parent(C,A), parent(C,B), sex(Y,'M'), not(brother(X,Y)).  
```


Примеры запросов/ответов:

```prolog
2 ?- cousin('Liubov Ivenkova',X).  
X = 'Ivan Rubin' ;  
X = 'Ivan Rubin' ;  
X = 'Timofei Rubin' ;  
X = 'Timofei Rubin' ;  
false.

3 ?- cousin('Vasilii_1 Ivenkov',X).  
X = 'Igor Ivenkov' ;  
X = 'Igor Ivenkov' ;  
false.

4 ?- cousin('Liubov Ivenkova','Ivan Rubin').  
true .

5 ?- cousin('Liubov Ivenkova','Olga Ivenkova').  
false.

6 ?- cousin(X,'Liubov Ivenkova').  
false.

7 ?- cousin(X,'Vasilii_1 Ivenkov').  
X = 'Igor Ivenkov' ;  
X = 'Igor Ivenkov' ;  
X = 'Larisa Ivenkova' ;  
X = 'Larisa Ivenkova' ;  
X = 'Liudmila' ;  
X = 'Liudmila' ;  
X = 'Olga' ;  
X = 'Olga' ;  
false.
```

## Определение степени родства

Для определения степени родства двух случайных людей я использовала поиск в ширину - так как он находит первым кратчайший путь.
Алгоритм поиска такой:
1) Для начала мы оперделяем несколько базовых отношений - брат/сестра/дочь/сын/мать/отец/муж/жена
2) Потом начинаем с помощью поиска в ширину идти от первого человека и дойти до второго. 
3) В итоге мы получим последовательность людей. А надо получить отношения родства. Для этого пишем предикат transform, делающий это. Так же надо в конце реверсировать полученный ответ.

```prolog
rodnye(P,S):-
    parent(P1,P),
    parent(P1,S),
    P \= S.

type(husband, H,W):-
    parent(H,C),
    parent(W,C),
    H \= W,
    sex(H,'M').

type(wife, W,H):-
    parent(H,C),
    parent(W,C),
    H \= W,
    sex(W,'F').

type(brother, B, Y):-
    rodnye(B, Y),
    sex(B,'M').

type(sister, S, Y):-
    rodnye(S, Y),
    sex(S,'F').

type(father, F,C):-
    parent(F,C),
    sex(F,'M').

type(mother, M,C):-
    parent(M,C),
    sex(M,'F').

type(parent, P,C):-
    parent(P,C).

type(son, C,P):-
    parent(P,C),
    sex(C,'M').

type(daughter, C,P):-
    parent(P,C),
    sex(C,'F').

type(child, C, P):-
    parent(P,C).

types(X):-
    member(X, [father, mother, sister, brother, son, daughter, husband, wife]).

relative(X, Y, Res):-
    search_bdth(X, Y, Res1),
    transform(Res1, Res).

transform([_],[]):-!. 
transform([X,Y|T],Res):-
    type(R,X,Y),
    Res = [R|Tmp],
    transform([Y|T],Tmp),!.

prolong([X|T],[Y,X|T]):-
    move(X,Y),
    not(member(Y,[X|T])).

move(X,Y):-
    type(_,X,Y).

search_bdth(X,Y,P):-
    bdth([[X]],Y,L),
    reverse(L,P).

bdth([[X|T]|_],X,[X|T]).
bdth([P|QI],X,R):-
    findall(Z,prolong(P,Z),T),
    append(QI,T,Q0),
    bdth(Q0,X,R).

bdth([_|T],Y,L):-
    bdth(T,Y,L).
```

**Результат работы**
```prolog
2 ?- relative('Liubov Ivenkova','Olga Ivenkova',X).
X = [sister] ;
X = [sister] ;
X = [daughter, father] ;
X = [daughter, father] ;
X = [daughter, mother] ;
X = [daughter, mother] ;
X = [daughter, father] ;
X = [daughter, father] ;
X = [daughter, mother] ;
X = [daughter, mother] .
```


## Естественно-языковый интерфейс

В моём варианте решения я задаю вопросы на английском языке.
1) Для начала составляем словари различных вопросов, специальных слов и форм родства ( брат - братья).
2) Затем для различных форм вопросов пишем их разбор. Для запоминания последних использованных имён используем предикат nb_getval.

Приведём пример одного из правил для предиката ask_question. Это правило находит ответ на вопрос, сколько определенных родственников имеет какой-то человек. Сначала мы проверяем корректность входных данных с помощью предикатов question_word, much_many, mn_chislo, help_word, have_has, question_mark. Также запоминаем, относительно имени какого человека задается вопрос, с помощью встроенного предиката nb_setval. Это потребуется в дальнейшем для обработки запросов с местоимениями. Приводим множественное число к единственному в предикате pural. ask_relative ищет всех запрашиваемых родственников заданного человека, а setof создает список из найденных уникальных имен. Далее получаем длину этого списка и печатаем результат в нужном порядке.

```prolog
%how many brothers does *name* have ?
ask_question(List):-
    List = [A,B,C,D,E,F,H],
    question_word(A),
    much_many(B),
    mn_chisla(C),
    help_word(D),
    (sex(E,'M');sex(E,'F')),
    nb_setval(lastName,E),
    have_has(F),
    question_mark(H),

    mn_chislo(C1,C),
    setof(X,ask_relative(X,E,C1),T),
    length(T,Res),!,
    write(E),
    write(" have "),
    ((Res =:= 1,write(Res),write(" "),write( C1));(not(Res =:= 1),write(Res),write(" "),write( C))),!.

%how many brothers does he have ?
ask_question(List):-
    List = [A,B,C1,D,E1,F,H],
    question_word(A),
    much_many(B),
    mn_chisla(C1),
    help_word(D),
    his_her(E1),
    nb_getval(lastName,E),
    have_has(F),
    question_mark(H),

    mn_chislo(C,C1),
    setof(X,ask_relative(X,E,C),T),
    length(T,Res),
    write(E),
    write(" have "),
    ((Res =:= 1,write(Res),write(" "),write(C));(not(Res =:= 1),write(Res),write(" "),write(C1))),!.
```

**Результат работы**
```prolog
2 ?- ask_question([who,is,'Iurii Rubin',"'s",son,?]).        
Ivan Rubin is Iurii Rubin's son
true ;
Timofei Rubin is Iurii Rubin's son
true ;
false.
```

## Выводы

В результате выполнения курсового проекта я получила следующие навыки и знания:

 1. Углубила свои познания в теоретической части логического программирования. После написания эссе мне стала понятна природа типов в логических языках, и почему создатели языков делали выбор в пользу типизации или ее отсутсвия. Теперь, если передо мной встанет задача, для решения которой лучше всего подойдет логическая парадигма, я точно сделаю адекватный выбор инструмента с учетом использования типов. Возможно, мне когда-нибудь придется участвовать в разработке логического языка, вот тогда-то я применю свои познания и приму грамотное архитектурное решение.
 2. Научилась обрабатывать данные в формате GEDCOM. Если в будущем мне понадобится обрабатывать генеалогические деревья, то мне не придется разбираться со структурой их хранения.
 3. Написала парсер, обрабатывающий текстовые данные. Пришлось изучить новый язык программирования - Python.
 4. Закрепила навыки, полученные в 3 лабораторной работе, связанные с поиском в пространстве состояний. В КП это было необходимо для построения цепочки родства.
 5. Закрепила навыки, полученные в 4 лабораторной работе, связанные в грамматическим разбором предложения.
 
Как уже было замечено в 3 лабораторной работе, поиск в ширину, который я использую для построения цепочки родства, имеет экспоненциальную сложность по памяти, поэтому если цепочка будет слишком длинной, то произойдет переполнение стека, и мы не получим никакого результата. Не считая этого, мой определитель родства работает корректно и может построить цепочку для любых двух людей из дерева.
