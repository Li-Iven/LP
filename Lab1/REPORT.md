# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Ивенкова Л.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В императивных языках  обычно принято хранить данные в массивах. Списки в языке Пролог отличаются от них: например в них нельзя обращаться к элементу списка по индексу - к нему можно получить доступ только последовательным перебором элементов. Также для списков не надо заранее объявлять рамер, как это нужно для массивово в большинстве имп. языков.  
Списки в языке Пролог похожи на односвязные списки в языке Си - в них так же происходит доступ к элементам.

## Задание 1.1: Реализация стандартных предикатов обработки списка.

Примеры использования:  

```prolog
2 ?- my_length([1,2,3,1], N).
N = 4.

3 ?- my_member(3, [1,2,3,2]). 
true ;
false.

4 ?- my_remove(2, [1,2,3,2,1], Res). 
Res = [1, 3, 2, 1] ;
Res = [1, 2, 3, 1] ;
false.

5 ?- my_append([0,1,6], [1,2,3], Res). 
Res = [1, 2, 3, 0, 1, 6] ;
false.

6 ?- my_permute([1,2],L).
L = [1, 2] ;
L = [2, 1] ;
false.

7 ?- my_sublist([1,2],[1,2,3,5,6,7]). 
true ;
false.
```

Реализация:  
```prolog

% вычисляет длину списка
my_length([], 0).  
my_length([_|Y], N):- my_length(Y, N1), N is N1 + 1.  

% проверяет принадлежность едемента А к списку
my_member(A, [A|_]).  
my_member(A, [_|Z]):- my_member(A, Z).  

% удаляет элемент значения X из списка
my_remove(X, [X|T], T).  
my_remove(X, [Y|T], [Y|Z]):- my_remove(X, T, Z).  

% конкатенация двух списков
my_append(X, [], X).  
my_append(X, [A|Y], [A|Z]):- my_append(X, Y, Z).  

% находит все перестановки списка L
my_permute([],[]).  
my_permute(L,[X|T]):- my_remove(X,L,R),my_permute(R,T).  

% проверяет, является ли список S подсписком для L
my_sublist(S,L):- my_append(_,L1,L),my_append(S,_,L1).
```

## Задание 1.2: Предикат обработки списка

а) remove_all(X,L,Res) - Удаление всех элементов списка по значению, на основе стандартных предикатов обработки списков  

Примеры использования:  

```prolog
1 ?- remove_all(1, [1,2,3,1,4], Res).  
Res = [2, 3, 4].  

2 ?- remove_all(6, [1,2,3,1,4], Res).  
Res = [1, 2, 3, 1, 4] ;  
false.  
```

Реализация:  
```prolog
remove_all(X,L,L) :- not(my_member(X, L)).  
remove_all(X,L,Res) :- my_member(X,L),my_remove(X,L,L2), remove_all(X,L2,Res), !.
```

**Принцип работы:**  

Пока в списке L есть элемент X:  
- Удаляем одно вхождение X в L, получаем новый список L2;  
- Вызываем этот же предикат для L2 и отсекаем последующие решения;  
В результате получаем итоговый список Res без элементов X.  

б) delete(X, L, Res) - Удаление всех элементов списка по значению, без использования стандартных предикатов обработки списков  

Примеры использования:  

```prolog
3 ?- delete(1,[1,2,3,1,4],Res).      
Res = [2, 3, 4].  

4 ?- delete(6,[1,2,3,1,4],Res).  
Res = [1, 2, 3, 1, 4].
```

Реализация:  
```prolog
delete(_, [], []):-!.  
delete(X, [X|T], Res):- delete(X, T, Res), !.  
delete(X, [H|T], [H|Res]):- delete(X, T, Res).
```

**Принцип работы:**  

- Если удаляем любой элемент из пустого списка - получаем пустой список, перкращаем поиск решений.  
- Если X стоит в голове списка, то удаляем его, а затем вызываем этот же предикат для его хвоста (+ отсекаем остальные решения).  
- Если X не стоит в голове списка, то ищем его в хвосте - вызываем наш предикат для хвоста.  


## Задание 1.3: Предикат обработки числового списка

а) sliyanie(L1,L2,Res) - Слияние двух упорядоченных списков, на основе стандартных предикатов обработки списков  
   
   Примеры использования:  
   
   ```prolog
   5 ?- sliyanie([1,2,3],[1,1,4,6],Res). 
   Res = [1, 1, 1, 2, 3, 4, 6] ;
   false.
   
   6 ?- sliyanie([],[1,1,4,6],Res).      
   Res = [1, 1, 4, 6] ;
   false.  
   ```
   
   Реализация:  
   ```prolog
   insert(nil,D,bt(nil,D,nil)).
   insert(bt(LT,K,RT),X,bt(Ltnew,K,RT)  ):-X=<K,insert(LT,X,Ltnew).
   insert(bt(LT,K,RT),X,bt(LT,K,Rtnew)  ):-X>K,insert(RT,X,Rtnew).
   ltotree([],nil).
   ltotree([H|X],T):-ltotree(X,T1),insert(T1,H,T).
   treetol(nil,[]).
   treetol(bt(LT,K,RT),S):-treetol(LT,S1), treetol(RT,S2), my_append([K|S2],S1,S).

   my_sort(L,L1):-ltotree(L,T),treetol(T,L1).

   sliyanie(L1,L2,Res) :- my_append(L1,L2,L), my_sort(L,Res).
   ```

   **Принцип работы:**  

   - Создаём сортирующее дерево (которое не удаляет одинаковые элементы);
   - С помощью предиката append объединяем списки L1 и L2 в список L;
   - Сортируем полученный список L с помощью созданного нами пердиката my_sort.  

б) merge_lists(L1, L2, Res) - Слияние двух упорядоченных списков, без использования стандартных предикатов обработки списков  
   
   Примеры использования:  
   
   ```prolog
   7 ?- merge_lists([1,2,3],[1,1,4,6],Res). 
   Res = [1, 1, 1, 2, 3, 4, 6].
   
   8 ?- merge_lists([],[1,1,4,6],Res).      
   Res = [1, 1, 4, 6].
   ```
   
   Реализация:  
   ```prolog
   merge_lists([], L2, L2):-!. 
   merge_lists(L1, [], L1):-!.  
   merge_lists([H1|T1], [H2|T2], [H1|Res]):- H1 =< H2, !, merge_lists(T1, [H2|T2], Res).  
   merge_lists(L1, [H2|T2], [H2|Res]):- merge_lists(L1, T2, Res).
   ```
   
   **Принцип работы:**  
   
   - Если объединяем пустой список L1 с непустым списком L2 (или наоборот), то возвращаем непустой список, отсекаем все остальные решения.  
   - Сравниваем головы списков - "удаляем" наименьшую голову, и дальше вызываем пердикат для объединения списков уже без этой наим. головы (в процессе обратного хода по рекурсии эта голова вернётся).

## Задание 1.4: Примеры совместного использования предикатов, реализованных в пунктах 1.2 и 1.3:


1) minus(L1,L2,Res) - Удаление элементов списка L1 из списка L2 (списки L1 и L2 упорядоченны).  
   
   Примеры использования:  
   
   ```prolog
   9 ?- minus([1,3,5],[1,1,2,3,4,5,6],Res).
   Res = [2, 4, 6].
   
   10 ?- minus([1,3,5],[1,1,2,3,4,5,6,6],Res). 
   Res = [2, 4, 6, 6].
   ```
   
   Реализация:  
   ```prolog
   minus([],L,L).
   minus([H|T],L2,Res) :- merge_lists([H|T],L2,L3), delete(H,L3,R), minus(T,R,Res).
   ```
   
   **Принцип работы:** 
   
   - Делаем слияние списков, получаем новый список L3.
   - Удаляем голову списка L1 из L3, получаем новый список R.
   - Вызываем предикат minus для списка R и хвоста списка L1.

2) no_copy(L1,L2,Res) - Объединяет списки L1 и L2 и удаляет оттуда все значения элементов, которые встречались в обоих списках (списки L1 и L2 упорядоченны).

   Примеры использования:  
   
   ```prolog
   11 ?- no_copy([1,3,5],[1,1,2,3,4,5,6,6],Res). 
   Res = [2, 4, 6, 6] ;
   false.
   ```
   
   Реализация:  
   ```prolog
   no_copy(L1,L2,Res) :- minus(L1,L2,R1), minus(L2,L1,R2), my_append(R1,R2,Res1), my_sort(Res1,Res).
   ```
   
   **Принцип работы:** 
   
   - Удаляем элементы 1-ого списка из второго, получаем новый список R1.
   - Удаляем элементы 2-ого списка из первого, получаем новый список R2.
   - Объединяем R1 и R2, получаем новый список Res, сортируем его.

## Задание 2: Реляционное представление данных

**Преимущества и недостатки реляционного представления**

Преимущества:  
- Простота  и доступность для понимания пользователем

Недостатки:
- Назкая скорость работы  
- Большой объём памати  
- Не всё можно представить в виде таблиц

**Преимущества и недостатки представления, которое я использовала (four)**

Преимущества:  
- Простота  и доступность для понимания пользователем
- Ёмкое пердставление данных (всего на 10 строк)

Недостатки:
- В предикате subject вторым элементом является список, состоящий опять же из предикатов grade, что затрудняет доступ к оценкам студентов.

**Принцип реализации всех предикатов, осуществляющих запросы к данным**

Вариант 1, представление four.pl

1) Списки групп и предметов:  
   groups(X) :- member(X,[101,102,103,104]).  
   subjects(X) :- member(X,['Логическое программирование','Математический анализ','Функциональное программирование','Информатика','Английский язык','Психология']).
2) student(G,X) :- group(G,L), member(X,L) - пердикат поиска студента группы.      
   Находит строку, в которой записаны студенты группы G, затем проходится по всем студентам записанным там.
3) ball(X,C) :- subject(_,L2), member(grade(X,C),L2) - предикат поиска оценок студента.  
   Перебирает все строки с предикатом subject. Обращается ко второму его элементу -  списку L2. Есди среди элементов этого списка он находит предикат grade(X,C) с фамилией нужного нам студента - берёт из него его оценку.
4) ball_of_student(G,C) :- student(G,X), ball(X,C) - предикат поиска оценок студента группы.  
   Находит всех студентов заданной группы и для каждого находит все его оценки.
5) sr_ball(G,Res) :- findall(Res, ball_of_student(G,Res), R), sum_list(R,Sum), my_length(R, Len),  Res is Sum/Len.  
   Предикат вычисления среднего балла конкретной группы.  
   Собирает в список все решения пердиката ball_of_student(G,Res), т.е. находит все оценки всех студентов группы. Далее вычисляет их сумму Sum и количество Len. Делит Sum на Len.
6) sr_ball_of_groups() - Предикат вычисления среднего балла для каждой из групп.

   Примеры использования:  
   
   ```prolog
   12 ?- sr_ball_of_groups().
   Группа: 101  Средний балл = 3.966666666666667
   Группа: 102  Средний балл = 3.9444444444444446
   Группа: 103  Средний балл = 4.145833333333333
   Группа: 104  Средний балл = 3.861111111111111
   false.
   ```
   
   Реализация:  
   ```prolog
   sr_ball_of_groups() :- groups(G), sr_ball(G,S), write("Группа: "), write(G), write("  Средний балл = "), write(S), write("\n"), fail.
   ```
   
   **Принцип работы:** 
   
   - Перебираем все группы.
   - Для каждой из них находим средний балл.
   - Печатаем результат.
7) no_pass(S,X) :- subject(S,C), member(grade(X,2),C).  
   Предикат поиска тех, кто не сдал этот предмет.  
   Перебирает все строки с предикатом subject. Обращается ко второму его элементу -  списку C. Есди среди элементов этого списка он находит предикат grade(X,2) то берёт из него его фамилию студента.
8) no_pass_sub() - Предикат поиска студентов ,не сдавших предмет для всех предметов.  

   Примеры использования:  
   
   ```prolog
   13 ?- no_pass_sub().
   Предмет: Логическое программирование,  Не сдали = [Петровский,Сидоров,Джаво]
   Предмет: Математический анализ,  Не сдали = [Петров]
   Предмет: Функциональное программирование,  Не сдали = []
   Предмет: Информатика,  Не сдали = [Сиплюсплюсов,Криптовалютников]
   Предмет: Английский язык,  Не сдали = [Решетников,Азурин]
   Предмет: Психология,  Не сдали = [Безумников,Круглосчиталкин]
   false.
   ```
   
   Реализация:  
   ```prolog
   no_pass_sub() :- subjects(S), findall(X, no_pass(S,X), Res), write("Предмет: "), write(S), write(",  Не сдали = "), write(Res), write("\n"), fail.
   ```
   
   **Принцип работы:** 
   
   - Перебираем все предметы.
   - Для каждого из них находим студентов, которые не сдали его.
   - Печатаем результат.
9) no_pass_student(G,X) :- student(G,X), ball(X,2).  
   Предикат поиска студентов в группе, которые не сдали хотя бы один предмет.  
   Перебирает всех студентов в группе. Находит все их оценки, и ищет среди них тех, у кого хотя бы одна оценка равна 2.
10) no_pass_in_groups() - Предикат поиска количества студентов, не сдавших экзамен, для всех групп.
    
    Примеры использования:  
    
    ```prolog
    14 ?- no_pass_in_groups().
    Группа: 101,  Не сдали = 3
    Группа: 102,  Не сдали = 3
    Группа: 103,  Не сдали = 2
    Группа: 104,  Не сдали = 2
    false.
    ```
    
    Реализация:   
    ```prolog
    no_pass_in_groups() :- groups(G), findall(X, no_pass_student(G,X), R), my_length(R, Len), write("Группа: "), write(G), write(",  Не сдали = "), write(Len), write("\n"), fail.
    ```
    
    **Принцип работы:** 
    
    - Перебираем все группы.
    - Для каждой из них находим студентов, которые не хотя бы один экзамен.
    - Печатаем результат.

## Выводы

В этой лабораторной работе я научилась работать со списками в языке Пролог. Я научилась обрабатывать списки с помощью стандартных предикатов обработки списков, а так же сама писать новые предикаты для их обработки на основе рекурсии и цикла for.  

Я познакомилась с таким понятием как реляционное представление данных. Научилась работать с реляционными базами данных - логически анализировать их, писать предикаты поиска информации в них и обработки этой информации (в том числе с помощью списков), вывода её ввиде таблиц.  
Эта часть лабораторной работы мне понравилась больше всего, так как с ней намного интереснее работать, и к тому же проще - по логике можно сразу понять что не так с твоим предикатом и как, зачем и почему он работает. Также здесь можно разбивать решение одного предиката на разные маленькие предикаты, каждый из которых выполняет какую-то отдельную функцию; это так же существенно упрощает решение задачи.

